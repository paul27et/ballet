import { Accessor } from "../..";
export declare const $RAW: unique symbol, $NODE: unique symbol, $NAME: unique symbol;
export declare type StoreNode = Record<keyof any, any>;
export declare type NotWrappable = string | number | bigint | symbol | boolean | Function | null | undefined;
export declare type Store<T> = DeepReadonly<T>;
export declare function isWrappable(obj: any): any;
export declare function unwrap<T extends StoreNode>(item: any, set?: Set<unknown>): T;
export declare function getDataNodes(target: StoreNode): any;
export declare function proxyDescriptor(target: StoreNode, property: keyof any): PropertyDescriptor | undefined;
export declare function ownKeys(target: StoreNode): (string | symbol)[];
export declare function createDataNode(): Accessor<void> & {
    $: () => void;
};
export declare function setProperty(state: StoreNode, property: keyof any, value: any): void;
export declare function updatePath(current: StoreNode, path: any[], traversed?: (keyof any)[]): void;
export declare type DeepReadonly<T> = {
    readonly [K in keyof T]: T[K] extends NotWrappable ? T[K] : DeepReadonly<T[K]>;
};
export declare type StoreSetter<T> = T | Partial<T> | ((prevState: T, traversed?: (keyof any)[]) => Partial<T> | void);
export declare type StorePathRange = {
    from?: number;
    to?: number;
    by?: number;
};
export declare type ArrayFilterFn<T> = (item: T, index: number) => boolean;
export declare type Part<T> = [T] extends [never] ? never : [keyof T] extends [never] ? never : keyof T | (keyof T)[] | (number extends keyof T ? ArrayFilterFn<T[number]> | StorePathRange : never);
export declare type Next<T, K extends Part<T>> = [K] extends [never] ? never : K extends keyof T ? T[K] : K extends (keyof T)[] ? T[K[number]] : number extends keyof T ? T[number] : never;
export declare type WrappableNext<T, K extends Part<T>> = Exclude<Next<T, K>, NotWrappable>;
declare type DistributeRest<T, K extends Part<T>> = K extends K ? [K, ...Rest<Next<T, K>>] : never;
export declare type Rest<T> = 0 extends 1 & T ? [...(keyof any)[], any] : [StoreSetter<T>] | (T extends NotWrappable ? never : DistributeRest<T, Part<T>>);
export declare type SetStoreFunction<T> = _SetStoreFunction<Store<T>>;
interface _SetStoreFunction<T> {
    <K1 extends Part<T>, K2 extends Part<T1>, K3 extends Part<T2>, K4 extends Part<T3>, K5 extends Part<T4>, K6 extends Part<T5>, K7 extends Part<T6>, T1 extends WrappableNext<T, K1>, T2 extends WrappableNext<T1, K2>, T3 extends WrappableNext<T2, K3>, T4 extends WrappableNext<T3, K4>, T5 extends WrappableNext<T4, K5>, T6 extends WrappableNext<T5, K6>>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, k7: K7, ...rest: Rest<Next<T6, K7>>): void;
    <K1 extends Part<T>, K2 extends Part<T1>, K3 extends Part<T2>, K4 extends Part<T3>, K5 extends Part<T4>, K6 extends Part<T5>, K7 extends Part<T6>, T1 extends WrappableNext<T, K1>, T2 extends WrappableNext<T1, K2>, T3 extends WrappableNext<T2, K3>, T4 extends WrappableNext<T3, K4>, T5 extends WrappableNext<T4, K5>, T6 extends WrappableNext<T5, K6>>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, k7: K7, setter: StoreSetter<Next<T6, K7>>): void;
    <K1 extends Part<T>, K2 extends Part<T1>, K3 extends Part<T2>, K4 extends Part<T3>, K5 extends Part<T4>, K6 extends Part<T5>, T1 extends WrappableNext<T, K1>, T2 extends WrappableNext<T1, K2>, T3 extends WrappableNext<T2, K3>, T4 extends WrappableNext<T3, K4>, T5 extends WrappableNext<T4, K5>>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, setter: StoreSetter<Next<T5, K6>>): void;
    <K1 extends Part<T>, K2 extends Part<T1>, K3 extends Part<T2>, K4 extends Part<T3>, K5 extends Part<T4>, T1 extends WrappableNext<T, K1>, T2 extends WrappableNext<T1, K2>, T3 extends WrappableNext<T2, K3>, T4 extends WrappableNext<T3, K4>>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, setter: StoreSetter<Next<T4, K5>>): void;
    <K1 extends Part<T>, K2 extends Part<T1>, K3 extends Part<T2>, K4 extends Part<T3>, T1 extends WrappableNext<T, K1>, T2 extends WrappableNext<T1, K2>, T3 extends WrappableNext<T2, K3>>(k1: K1, k2: K2, k3: K3, k4: K4, setter: StoreSetter<Next<T3, K4>>): void;
    <K1 extends Part<T>, K2 extends Part<T1>, K3 extends Part<T2>, T1 extends WrappableNext<T, K1>, T2 extends WrappableNext<T1, K2>>(k1: K1, k2: K2, k3: K3, setter: StoreSetter<Next<T2, K3>>): void;
    <K1 extends Part<T>, K2 extends Part<T1>, T1 extends WrappableNext<T, K1>>(k1: K1, k2: K2, setter: StoreSetter<Next<T1, K2>>): void;
    <K extends Part<T>>(k: K, setter: StoreSetter<Next<T, K>>): void;
    (setter: StoreSetter<T>): void;
}
/**
 * creates a reactive store that can be read through a proxy object and written with a setter function
 *
 * @description https://www.solidjs.com/docs/latest/api#createstore
 */
export declare function createStore<T extends StoreNode>(store: T | Store<T>, options?: {
    name?: string;
}): [get: Store<T>, set: SetStoreFunction<T>];
export {};
