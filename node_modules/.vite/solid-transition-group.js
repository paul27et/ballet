import {
  batch,
  children,
  createComputed,
  createEffect,
  createSignal,
  mergeProps,
  untrack
} from "./chunk-BKZX72A2.js";

// node_modules/solid-transition-group/dist/solid-transition-group.js
var Transition = (props) => {
  let el;
  let first = true;
  const [s1, set1] = createSignal();
  const [s2, set2] = createSignal();
  const resolved = children(() => props.children);
  const name = props.name || "s";
  props = mergeProps({
    name,
    enterActiveClass: name + "-enter-active",
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    exitActiveClass: name + "-exit-active",
    exitClass: name + "-exit",
    exitToClass: name + "-exit-to"
  }, props);
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit
  } = props;
  function enterTransition(el2, prev) {
    if (!first || props.appear) {
      let endTransition = function() {
        if (el2) {
          el2.classList.remove(...enterActiveClasses);
          el2.classList.remove(...enterToClasses);
          batch(() => {
            s1() !== el2 && set1(el2);
            s2() === el2 && set2(void 0);
          });
          onAfterEnter && onAfterEnter(el2);
          if (props.mode === "inout")
            exitTransition(el2, prev);
        }
      };
      const enterClasses = props.enterClass.split(" ");
      const enterActiveClasses = props.enterActiveClass.split(" ");
      const enterToClasses = props.enterToClass.split(" ");
      onBeforeEnter && onBeforeEnter(el2);
      el2.classList.add(...enterClasses);
      el2.classList.add(...enterActiveClasses);
      requestAnimationFrame(() => {
        el2.classList.remove(...enterClasses);
        el2.classList.add(...enterToClasses);
        onEnter && onEnter(el2, endTransition);
        if (!onEnter || onEnter.length < 2) {
          el2.addEventListener("transitionend", endTransition, {
            once: true
          });
          el2.addEventListener("animationend", endTransition, {
            once: true
          });
        }
      });
    }
    prev && !props.mode ? set2(el2) : set1(el2);
  }
  function exitTransition(el2, prev) {
    const exitClasses = props.exitClass.split(" ");
    const exitActiveClasses = props.exitActiveClass.split(" ");
    const exitToClasses = props.exitToClass.split(" ");
    if (!prev.parentNode)
      return endTransition();
    onBeforeExit && onBeforeExit(prev);
    prev.classList.add(...exitClasses);
    prev.classList.add(...exitActiveClasses);
    requestAnimationFrame(() => {
      prev.classList.remove(...exitClasses);
      prev.classList.add(...exitToClasses);
    });
    onExit && onExit(prev, endTransition);
    if (!onExit || onExit.length < 2) {
      prev.addEventListener("transitionend", endTransition, {
        once: true
      });
      prev.addEventListener("animationend", endTransition, {
        once: true
      });
    }
    function endTransition() {
      prev.classList.remove(...exitActiveClasses);
      prev.classList.remove(...exitToClasses);
      s1() === prev && set1(void 0);
      onAfterExit && onAfterExit(prev);
      if (props.mode === "outin")
        enterTransition(el2, prev);
    }
  }
  createComputed((prev) => {
    el = resolved();
    while (typeof el === "function")
      el = el();
    return untrack(() => {
      if (el && el !== prev) {
        if (props.mode !== "outin")
          enterTransition(el, prev);
        else if (first)
          set1(el);
      }
      if (prev && prev !== el && props.mode !== "inout")
        exitTransition(el, prev);
      first = false;
      return el;
    });
  });
  return [s1, s2];
};
function getRect(element) {
  const {
    top,
    bottom,
    left,
    right,
    width,
    height
  } = element.getBoundingClientRect();
  const parentRect = element.parentNode.getBoundingClientRect();
  return {
    top: top - parentRect.top,
    bottom,
    left: left - parentRect.left,
    right,
    width,
    height
  };
}
var TransitionGroup = (props) => {
  const resolved = children(() => props.children);
  const name = props.name || "s";
  props = mergeProps({
    name,
    enterActiveClass: name + "-enter-active",
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    exitActiveClass: name + "-exit-active",
    exitClass: name + "-exit",
    exitToClass: name + "-exit-to",
    moveClass: name + "-move"
  }, props);
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit
  } = props;
  const [combined, setCombined] = createSignal();
  let p = [];
  let first = true;
  createComputed(() => {
    const c = resolved();
    const comb = [...c];
    const next = new Set(c);
    const prev = new Set(p);
    const enterClasses = props.enterClass.split(" ");
    const enterActiveClasses = props.enterActiveClass.split(" ");
    const enterToClasses = props.enterToClass.split(" ");
    const exitClasses = props.exitClass.split(" ");
    const exitActiveClasses = props.exitActiveClass.split(" ");
    const exitToClasses = props.exitToClass.split(" ");
    for (let i = 0; i < c.length; i++) {
      const el = c[i];
      if (!first && !prev.has(el)) {
        let endTransition = function() {
          if (el) {
            el.classList.remove(...enterActiveClasses);
            el.classList.remove(...enterToClasses);
            onAfterEnter && onAfterEnter(el);
          }
        };
        onBeforeEnter && onBeforeEnter(el);
        el.classList.add(...enterClasses);
        el.classList.add(...enterActiveClasses);
        requestAnimationFrame(() => {
          el.classList.remove(...enterClasses);
          el.classList.add(...enterToClasses);
          onEnter && onEnter(el, endTransition);
          if (!onEnter || onEnter.length < 2) {
            el.addEventListener("transitionend", endTransition, {
              once: true
            });
            el.addEventListener("animationend", endTransition, {
              once: true
            });
          }
        });
      }
    }
    for (let i = 0; i < p.length; i++) {
      const old = p[i];
      if (!next.has(old) && old.parentNode) {
        let endTransition = function() {
          old.classList.remove(...exitActiveClasses);
          old.classList.remove(...exitToClasses);
          onAfterExit && onAfterExit(old);
          p = p.filter((i2) => i2 !== old);
          setCombined(p);
        };
        comb.splice(i, 0, old);
        onBeforeExit && onBeforeExit(old);
        old.classList.add(...exitClasses);
        old.classList.add(...exitActiveClasses);
        requestAnimationFrame(() => {
          old.classList.remove(...exitClasses);
          old.classList.add(...exitToClasses);
        });
        onExit && onExit(old, endTransition);
        if (!onExit || onExit.length < 2) {
          old.addEventListener("transitionend", endTransition, {
            once: true
          });
          old.addEventListener("animationend", endTransition, {
            once: true
          });
        }
      }
    }
    p = comb;
    setCombined(comb);
  });
  createEffect((nodes) => {
    const c = combined();
    c.forEach((child) => {
      let n;
      if (!(n = nodes.get(child))) {
        nodes.set(child, n = {
          pos: getRect(child),
          new: !first
        });
      } else if (n.new) {
        n.new = false;
        n.newPos = getRect(child);
      }
      if (n.new) {
        child.addEventListener("transitionend", () => {
          n.new = false;
          child.parentNode && (n.newPos = getRect(child));
        }, {
          once: true
        });
      }
      n.newPos && (n.pos = n.newPos);
      n.newPos = getRect(child);
    });
    if (first) {
      first = false;
      return nodes;
    }
    c.forEach((child) => {
      const c2 = nodes.get(child);
      const oldPos = c2.pos;
      const newPos = c2.newPos;
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        c2.moved = true;
        const s = child.style;
        s.transform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
      }
    });
    document.body.offsetHeight;
    c.forEach((child) => {
      const c2 = nodes.get(child);
      if (c2.moved) {
        let endTransition = function(e) {
          if (e && e.target !== child || !child.parentNode)
            return;
          if (!e || /transform$/.test(e.propertyName)) {
            child.removeEventListener("transitionend", endTransition);
            child.classList.remove(...moveClasses);
          }
        };
        c2.moved = false;
        const s = child.style;
        const moveClasses = props.moveClass.split(" ");
        child.classList.add(...moveClasses);
        s.transform = s.transitionDuration = "";
        child.addEventListener("transitionend", endTransition);
      }
    });
    return nodes;
  }, /* @__PURE__ */ new Map());
  return combined;
};
export {
  Transition,
  TransitionGroup
};
//# sourceMappingURL=solid-transition-group.js.map
